
using System.Globalization;
using System.Text;

namespace HW03;

public struct Rsa
{
    private ulong _p, _q, _n, _lamn, _e, _d;

    public void GenerateRandomKeys(Random r)
    {
        _p = r.GetRandomPrime(uint.MaxValue);
        _q = r.GetRandomPrime(uint.MaxValue);
        _n = _p * _q;
        _lamn = Math.Lcm(_p - 1, _q - 1);
        _e = 65537;
        _d = Math.ModInv.ModInverse(_e, _lamn);
    }
    
    /*
     The Encrypt function encrypts a string into ciphertext in blocks.
     Each block is 4 bytes long. The input string is deconstructed into bytes, and is then encrypted with the public key
     in 4 byte blocks. The construction of the blocks is detailed above the EncryptBlocks function.
     
     The encrypted blocks don't have a fixed length. To tackle this, during encryption, the longest encrypted block is
     found and every other block is padded with leading zeros, which are easily lost by just parsing the block as a
     number. The normalized block length is then placed as the first two digits of the whole ciphertext. e.g.
     19(large amount of numbers) would mean that each block is 19 digits long. These two leading digits are trimmed off
     the ciphertext before starting to decrypt blocks, and exist only for the function itself.
     */
    public void Encrypt()
    {
        Console.WriteLine("Enter string to encrypt:");
        var toEncrypt = InOut.GetStringInput();
        var bytes = Encoding.UTF8.GetBytes(toEncrypt);
        var encryptedBlocks = new List<string>();
        
        for (var i = 0; i < bytes.Length; i += 6)
        {
            encryptedBlocks.Add(i + 6 > toEncrypt.Length
                ? EncryptBlock(bytes[i..])
                : EncryptBlock(bytes[i..(i+6)]));
        }
        
        var maxLen = encryptedBlocks.Aggregate("", (max, cur) => max.Length > cur.Length ? max : cur).Length;
        var outString = "";
        if (maxLen < 10) outString += "0";
        outString += maxLen.ToString();
        
        for (var i = 0; i < encryptedBlocks.Count; i++)
        {
            while (encryptedBlocks[i].Length < maxLen)
            {
                encryptedBlocks[i] = encryptedBlocks[i].Insert(0, "0");
            }

            outString += encryptedBlocks[i];
        }

        Console.WriteLine("Encrypted blocks: ");
        Console.WriteLine(outString);
    }

    /*
     The Decrypt function is just a reversal of the Encrypt function (surprise)
     It takes a string input from the user, which is presumed to be a ciphertext generated by this same program.
     It then isolates the block length variable from the first two digits of the ciphertext, and trims them from the
     string. The string is then fed into the DecryptBlock function block by block, which handles actually decrypting
     each block.
     */
    public void Decrypt()
    {
        Console.WriteLine("Enter encrypted string to decrypt:");
        int blockLength;
        string toDecrypt;
        while (true)
        {
            toDecrypt = InOut.GetStringInput();
            if (int.TryParse(toDecrypt.AsSpan(0, 2), out blockLength)) break;
            Console.WriteLine("Error parsing block length!");
        }

        toDecrypt = toDecrypt.Remove(0, 2);

        var decryptedBytes = new List<byte>();
        for (var i = 0; i <= toDecrypt.Length - blockLength; i += blockLength)
        {
            var decryptedBlock = DecryptBlock(toDecrypt.Substring(i, blockLength));
            if (decryptedBlock == null)
            {
                Console.WriteLine("Decryption failed!");
                return;
            }
            decryptedBytes.AddRange(decryptedBlock);
        }
        
        Console.WriteLine("Decrypted text:");
        Console.WriteLine(Encoding.UTF8.GetString(decryptedBytes.ToArray()));
    }

    /*
     Functionality of EncryptBlock
     Consider the string "AAAA". The letter A is a single-byte value, and the value representing it is 65. Since we have
     four A-s, the string could be represented as 65,65,65,65. For encryption we consider the entire string a number instead.
     This number would logically be 65656565, but the numeric values of bytes can be up to 3 digits long, so we pad each
     repetition with a 0: 065065065065. Since a number can't start with a zero, we also start this number with a "1"
     by default. Thus, the string "AAAA" will become 1065065065065 for encryption purposes.
     
     In case of multi-byte characters, the blocks and characters might not line up. This along with block byte size
     consistency is the reason for using byte count instead of char count for blocks. When we consider the whole string
     as an array of bytes for everything except displaying it, then we can easily handle multi-byte characters.
     */
    private string EncryptBlock(IEnumerable<byte> bytes)
    {
        var toNumber = "1";
        
        foreach (var cByte in bytes)
        {
            if (cByte < 10) toNumber += "00";
            else if (cByte < 100) toNumber += "0";
            toNumber += cByte.ToString();
        }

        if (!ulong.TryParse(toNumber, out var textNum))
        {
            Console.WriteLine("Error parsing input!");
            return "";
        }

        var outVar = Math.ModPow(textNum, _e, _n);
        return outVar.ToString("X");
    }

    /*
     DecryptBlock takes a string presumed to be a block encrypted by the EncryptBlock function. It decrypts the block,
     parses it as a string, trims the leading "1" added by EncryptBlock, and parses every 3 digits of the decrypted
     number as bytes.
     e.g.: Decrypting the ciphertext yields the number 1065065065065.
     The function will then trim the 1: 065065065065
     It will then create a byte array with a third of the length of the number: 12/3 = 4, thus new byte[4]
     Then the number will be split into pieces of 3 digits, and put into the byte array:
     bytes = [ 65, 65, 65, 65 ]
     which are our original bytes.
     */
    private byte[]? DecryptBlock(string toDecrypt)
    {
        if (!ulong.TryParse(toDecrypt, NumberStyles.HexNumber, null, out var textNum))
        {
            Console.WriteLine("Error parsing input!");
            return null;
        }

        var decNum = Math.ModPow(textNum, _d, _n);
        var toParse = decNum.ToString();

        toParse = toParse.Remove(0, 1);
        var bytes = new byte[toParse.Length / 3];

        for (var i = 3; i <= toParse.Length; i += 3)
        {
            bytes[i / 3 - 1] = (byte)int.Parse(toParse.Substring(i - 3, 3));
        }
        
        return bytes;
    }
}